---
title: "ProcGen Fun 4: Recursive sampling"
summary: A more functional way of implementing a repeat distribution
---

[[List of posts](/2024/12/18/PGF-00/#list-of-posts) | [source code for this
post](https://github.com/djcarter85/ProcGenFun/tree/post-04)]

In [a previous post](/2025/01/01/PGF-02) we implemented a function which
transforms a single-valued distribution into a distribution returning multiple
values, as follows.

```cs
public static IDistribution<IEnumerable<T>> Repeat<T>(
    this IDistribution<T> dist, int count) =>
    new RepeatDistribution<T>(dist, count);

private class RepeatDistribution<T>(IDistribution<T> dist, int count) :
    IDistribution<IEnumerable<T>>
{
    public IEnumerable<T> Sample<TRng>(TRng rng) where TRng : notnull, IRng
    {
        for (int i = 0; i < count; i++)
        {
            yield return dist.Sample(rng);
        }
    }
}
```

At the time it irked me a little that we had to introduce a new class to
implement this. Granted, it's private, and so can't be seen outside of scope of
this class, but it would be nice to try and implement this using a more
functional approach.

Well, today I had a brainwave - use
[recursion](https://en.wikipedia.org/wiki/Recursion_(computer_science))!

Here's my refactored version, in all its glory:

```cs
public static IDistribution<IEnumerable<T>> Repeat<T>(
    this IDistribution<T> dist, int count)
{
    if (count < 0)
    {
        throw new ArgumentOutOfRangeException(
            nameof(count), count, "Count must be non-negative");
    }

    if (count == 0)
    {
        return Singleton.New(Enumerable.Empty<T>());
    }

    return
        from values in dist.Repeat(count - 1)
        from value in dist
        select values.Append(value);
}
```

I've added argument validation, as it doesn't make sense to have a negative
number of values. (I really should have added this in at first, but that's
life.)

We start with the base case: if the caller has asked for a count of zero, then
they will always get an empty sequence. For this we can use a singleton
distribution.

In the general case, we can use the same function to generate all but the last
value, and then sample from the distribution once and append it to the result.
Using query syntax for this works quite well I think, as it's clear that we're
building up the resultant distribution from simpler ones.

So there you have it: proof that sometimes solutions to problems just pop into
your head. Next time I'll fulfil my promise of more mazes!
